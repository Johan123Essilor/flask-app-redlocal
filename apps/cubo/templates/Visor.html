<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>3D Box Viewer</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/estilo3D.css') }}">

</head>
<body>
  <header>
    <h1>{{ cliente.name }} </h1>
    
    <nav id="cubeSelector"></nav>
  </header>
 <div id="btnSelected"></div>
  <main>
    <div class="container" id="cube"></div>
  </main>
 

  <script>
    var btnValue = "D2"
    const clienteData = {{ cliente | tojson }};
    const cube = document.getElementById('cube');
    const nav = document.getElementById('cubeSelector');
    let isDragging = false;
    let prevX, prevY;
    let rotX = -10, rotY = 20;

    // Definimos 6 cubos con diferentes dimensiones y colores
    const cubesData = {
      cube1: { w: 100, h: 150, d: 75, zli:38, zld:63, zts: 38, zti: 113, color: '#C2A073', label: 'FS' },
      cube2: { w: 200, h: 100, d: 133, zli:67, zld:133, zts: 67, zti: 33, zf:0,color: '#C2A073', label: 'DS' },
      cube3: { w: 200, h: 150, d: 150, zli:75, zld:125, zts: 75, zti: 75, color: '#C2A073', label: 'A' },
      cube4: { w: 300, h: 150, d: 225, zli:113, zld:188, zts: 113, zti: 38, color: '#C2A073', label: 'B' },
      cube5: { w: 400, h: 150, d: 260, zli:130, zld:270, zts: 130, zti: 20, color: '#C2A073', label: 'C' },
      cube6: { w: 400, h: 275, d: 240, zli:120, zld:280, zts: 120, zti: 155, color: '#C2A073', label: 'D' },
      cube7: { w: 400, h: 300, d: 260, zli:130, zld:270, zts: 130, zti: 170, color: '#C2A073', label: 'D2' },
      cube8: { w: 400, h: 300, d: 300, zli:150, zld:250, zts: 150, zti: 150, color: '#C2A073', label: 'F' }
    };

    // Función para crear el nav dinámico
    function createNav() {
  for (const key in cubesData) {
    
    const btn = document.createElement('button');
    btn.textContent = cubesData[key].label;
    
    btn.dataset.cube = key;

    btn.addEventListener('click', () => {
      document.getElementById("btnSelected").textContent = cubesData[key].label;
      btnValue = cubesData[key].label;
      setActiveButton(btn);
      setCube(key);
      
    });

    nav.appendChild(btn);
  }
}


    function setActiveButton(activeBtn) {
      // Remueve clase active de todos y la agrega sólo al seleccionado
      [...nav.children].forEach(btn => btn.classList.remove('active'));
      activeBtn.classList.add('active');
    }

    // Construye el cubo basado en el nombre de cubo

    function setCube(name) {
      const { w, h, d, zli, zld, zts, zti, color } = cubesData[name];
      cube.style.width = w + 'px';
      cube.style.height = h + 'px';

      cube.innerHTML = `
        <div class="face front" style="width:${w}px; height:${h}px; transform: translateZ(${d/2}px); background-color: ${color};font-size: 12px;">${btnValue}</div>
        <div class="face back" style="width:${w}px; height:${h}px; transform: rotateY(180deg) translateZ(${d / 2}px); background-color: ${color};font-size: 12px;">Posterior</div>
        <div class="face right" style="width:${d}px; height:${h}px; transform: rotateY(90deg) translateZ(${zld}px); background-color: ${color};font-size: 12px;">Derecha</div>
        <div class="face left" style="width:${d}px; height:${h}px; transform: rotateY(-90deg) translateZ(${zli}px); background-color: ${color};font-size: 12px;">Izquierda</div>
        <div class="face top" style="width:${w}px; height:${d}px; transform: rotateX(90deg) translateZ(${zts}px); background-color: ${color};font-size: 12px;">Superior</div>
        <div class="face bottom" style="width:${w}px; height:${d}px; transform: rotateX(-90deg) translateZ(${zti}px); background-color: ${color};font-size: 12px;">Inferior</div>
      `;

        rotX = -10; rotY = 20;
        cube.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;

        // Agrega cara extra (opcional)
      addExtraFaceUCC({
        reference: clienteData[btnValue].UCCface,
        offset: clienteData[btnValue].UCCoffset,
        width: clienteData[btnValue].UCCetiquetaWidth,
        height: clienteData[btnValue].UCCetiquetaHeight,  // ✅
        cubeData: cubesData[name],
        x: clienteData[btnValue].UCCX,                     // ✅
        y: clienteData[btnValue].UCCY
      });
      
      addExtraFace({
        reference: clienteData[btnValue].face,
        offset: clienteData[btnValue].offset,
        width: clienteData[btnValue].etiquetaWidth,
        height: clienteData[btnValue].etiquetaHeight,  // ✅
        cubeData: cubesData[name],
        x: clienteData[btnValue].X,                     // ✅
        y: clienteData[btnValue].Y
      });
      addExtraFace2({
        reference: clienteData[btnValue].face2,
        offset: clienteData[btnValue].offset2,
        width: clienteData[btnValue].etiquetaWidth2,
        height: clienteData[btnValue].etiquetaHeight2,  // ✅
        cubeData: cubesData[name],
        x: clienteData[btnValue].X2,                     // ✅
        y: clienteData[btnValue].Y2
      });



      
    }
function addExtraFaceUCC({ reference = 'front', offset = 20, width = 100, height = 100, cubeData,x, y}) {
  const { w, h, d } = cubeData;

  const extra = document.createElement('div');
  extra.className = 'face';
  extra.style.background = 'white';
  extra.style.opacity = 0.9;
  extra.style.width = `${width}px`;
  extra.style.height = `${height}px`;
  extra.textContent = 'UCC';

  let transform = '';

 switch (reference) {
    case 'front':
      transform = `translateZ(${d / 2 + offset}px) translateX(${x}px) translateY(${y}px)`;  // Mover a la izquierda y abajo
      break;
    case 'back':
      transform = `rotateY(180deg) translateZ(${d / 2 + offset}px) translateX(${x}px) translateY(${y}px)`;  // Mover a la izquierda y abajo
      break;
    case 'right':
      transform = `rotateY(90deg) translateZ(${d / 2 + offset}px) translateX(${x}px) translateY(${y}px)`;  // Mover a la izquierda y abajo
      break;
    case 'left':
      transform = `rotateY(-90deg) translateZ(${d / 2 + offset}px) translateX(${x}px) translateY(${y}px)`;  // Mover a la izquierda y abajo
      break;
    case 'top':
      transform = `rotateX(90deg) translateZ(${d / 2 + offset}px) translateX(${x}px) translateY(${y}px)`;  // Mover a la izquierda y abajo
      break;
    case 'bottom':
      transform = `rotateX(-90deg) translateZ(${d / 2 + offset}px) translateX(${x}px) translateY(${y}px)`;  // Mover a la izquierda y abajo
      break;
    default:
      console.warn('Referencia no válida');
      return;
  }


  extra.style.transform = transform;
  cube.appendChild(extra);
}
  function addExtraFace({ reference = 'front', offset = 20, width = 100, height = 100, cubeData,x, y}) {
  const { w, h, d } = cubeData;

  const extra = document.createElement('div');
  extra.className = 'face';
  extra.style.background = 'white';
  extra.style.opacity = 0.9;
  extra.style.width = `${width}px`;
  extra.style.height = `${height}px`;
  extra.textContent = 'FACE';

  let transform = '';

 switch (reference) {
    case 'front':
      transform = `translateZ(${d / 2 + offset}px) translateX(${x}px) translateY(${y}px)`;  // Mover a la izquierda y abajo
      break;
    case 'back':
      transform = `rotateY(180deg) translateZ(${d / 2 + offset}px) translateX(-10px) translateY(10px)`;  // Mover a la izquierda y abajo
      break;
    case 'right':
      transform = `rotateY(90deg) translateZ(${w / 2 + offset}px) translateX(-10px) translateY(10px)`;  // Mover a la izquierda y abajo
      break;
    case 'left':
      transform = `rotateY(-90deg) translateZ(${w / 2 + offset}px) translateX(-10px) translateY(10px)`;  // Mover a la izquierda y abajo
      break;
    case 'top':
      transform = `rotateX(90deg) translateZ(${h / 2 + offset}px) translateX(-10px) translateY(10px)`;  // Mover a la izquierda y abajo
      break;
    case 'bottom':
      transform = `rotateX(-90deg) translateZ(${h / 2 + offset}px) translateX(-10px) translateY(10px)`;  // Mover a la izquierda y abajo
      break;
    default:
      console.warn('Referencia no válida');
      return;
  }


  extra.style.transform = transform;
  cube.appendChild(extra);
}

function addExtraFace2({ reference = 'front', offset = 20, width = 100, height = 100, cubeData,x, y}) {
  const { w, h, d } = cubeData;

  const extra = document.createElement('div');
  extra.className = 'face';
  extra.style.background = 'white';
  extra.style.opacity = 0.9;
  extra.style.width = `${width}px`;
  extra.style.height = `${height}px`;
  extra.textContent = 'FACE2';

  let transform = '';

 switch (reference) {
    case 'front':
      transform = `translateZ(${d / 2 + offset}px) translateX(${x}px) translateY(${y}px)`;  // Mover a la izquierda y abajo
      break;
    case 'back':
      transform = `rotateY(180deg) translateZ(${d / 2 + offset}px) translateX(-10px) translateY(10px)`;  // Mover a la izquierda y abajo
      break;
    case 'right':
      transform = `rotateY(90deg) translateZ(${w / 2 + offset}px) translateX(-10px) translateY(10px)`;  // Mover a la izquierda y abajo
      break;
    case 'left':
      transform = `rotateY(-90deg) translateZ(${w / 2 + offset}px) translateX(-10px) translateY(10px)`;  // Mover a la izquierda y abajo
      break;
    case 'top':
      transform = `rotateX(90deg) translateZ(${h / 2 + offset}px) translateX(-10px) translateY(10px)`;  // Mover a la izquierda y abajo
      break;
    case 'bottom':
      transform = `rotateX(-90deg) translateZ(${h / 2 + offset}px) translateX(-10px) translateY(10px)`;  // Mover a la izquierda y abajo
      break;
    default:
      console.warn('Referencia no válida');
      return;
  }


  extra.style.transform = transform;
  cube.appendChild(extra);
}

    // Drag y touch para rotar cubo
    function getTouchPos(e) {
      const touch = e.touches[0];
      return { x: touch.clientX, y: touch.clientY };
    }

    document.addEventListener('mousedown', e => {
      if (e.target.closest('#cube')) {
        isDragging = true;
        prevX = e.clientX;
        prevY = e.clientY;
        cube.style.cursor = 'grabbing';
      }
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
      cube.style.cursor = 'grab';
    });

    document.addEventListener('mousemove', e => {
      if (!isDragging) return;
      const dx = e.clientX - prevX;
      const dy = e.clientY - prevY;
      prevX = e.clientX;
      prevY = e.clientY;
      rotY += dx * 0.4;
      rotX -= dy * 0.4;
      cube.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;
    });

    document.addEventListener('touchstart', e => {
      if (e.target.closest('#cube')) {
        isDragging = true;
        const pos = getTouchPos(e);
        prevX = pos.x;
        prevY = pos.y;
      }
    });

    document.addEventListener('touchend', () => {
      isDragging = false;
    });

    document.addEventListener('touchmove', e => {
      if (!isDragging) return;
      e.preventDefault();
      const pos = getTouchPos(e);
      const dx = pos.x - prevX;
      const dy = pos.y - prevY;
      prevX = pos.x;
      prevY = pos.y;
      rotY += dx * 0.4;
      rotX -= dy * 0.4;
      cube.style.transform = `rotateX(${rotX}deg) rotateY(${rotY}deg)`;
    }, { passive: false });

    // Inicializamos nav y cubo por defecto
    createNav();
    // Seleccionar el primer cubo por defecto y activar botón
    nav.children[0].classList.add('active');
    setCube(Object.keys(cubesData)[0]);
  </script>
</body>
</html>
